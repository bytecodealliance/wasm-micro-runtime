/* automatically generated by rust-bindgen 0.66.1 */
#![allow(non_snake_case)]			// turn off warning about snake_case name
#![allow(non_camel_case_types)]		// turn off warning about upper camel case type name
#![allow(non_upper_case_globals)]	// turn off warning about global non upper camel name

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub type __u_char = ::core::ffi::c_uchar;
pub type __u_short = ::core::ffi::c_ushort;
pub type __u_int = ::core::ffi::c_uint;
pub type __u_long = ::core::ffi::c_ulong;
pub type __int8_t = ::core::ffi::c_schar;
pub type __uint8_t = ::core::ffi::c_uchar;
pub type __int16_t = ::core::ffi::c_short;
pub type __uint16_t = ::core::ffi::c_ushort;
pub type __int32_t = ::core::ffi::c_int;
pub type __uint32_t = ::core::ffi::c_uint;
pub type __int64_t = ::core::ffi::c_long;
pub type __uint64_t = ::core::ffi::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::core::ffi::c_long;
pub type __u_quad_t = ::core::ffi::c_ulong;
pub type __intmax_t = ::core::ffi::c_long;
pub type __uintmax_t = ::core::ffi::c_ulong;
pub type __dev_t = ::core::ffi::c_ulong;
pub type __uid_t = ::core::ffi::c_uint;
pub type __gid_t = ::core::ffi::c_uint;
pub type __ino_t = ::core::ffi::c_ulong;
pub type __ino64_t = ::core::ffi::c_ulong;
pub type __mode_t = ::core::ffi::c_uint;
pub type __nlink_t = ::core::ffi::c_ulong;
pub type __off_t = ::core::ffi::c_long;
pub type __off64_t = ::core::ffi::c_long;
pub type __pid_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::core::ffi::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::core::mem::MaybeUninit<__fsid_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::core::ffi::c_long;
pub type __rlim_t = ::core::ffi::c_ulong;
pub type __rlim64_t = ::core::ffi::c_ulong;
pub type __id_t = ::core::ffi::c_uint;
pub type __time_t = ::core::ffi::c_long;
pub type __useconds_t = ::core::ffi::c_uint;
pub type __suseconds_t = ::core::ffi::c_long;
pub type __suseconds64_t = ::core::ffi::c_long;
pub type __daddr_t = ::core::ffi::c_int;
pub type __key_t = ::core::ffi::c_int;
pub type __clockid_t = ::core::ffi::c_int;
pub type __timer_t = *mut ::core::ffi::c_void;
pub type __blksize_t = ::core::ffi::c_long;
pub type __blkcnt_t = ::core::ffi::c_long;
pub type __blkcnt64_t = ::core::ffi::c_long;
pub type __fsblkcnt_t = ::core::ffi::c_ulong;
pub type __fsblkcnt64_t = ::core::ffi::c_ulong;
pub type __fsfilcnt_t = ::core::ffi::c_ulong;
pub type __fsfilcnt64_t = ::core::ffi::c_ulong;
pub type __fsword_t = ::core::ffi::c_long;
pub type __ssize_t = ::core::ffi::c_long;
pub type __syscall_slong_t = ::core::ffi::c_long;
pub type __syscall_ulong_t = ::core::ffi::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::core::ffi::c_char;
pub type __intptr_t = ::core::ffi::c_long;
pub type __socklen_t = ::core::ffi::c_uint;
pub type __sig_atomic_t = ::core::ffi::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::core::ffi::c_schar;
pub type int_fast16_t = ::core::ffi::c_long;
pub type int_fast32_t = ::core::ffi::c_long;
pub type int_fast64_t = ::core::ffi::c_long;
pub type uint_fast8_t = ::core::ffi::c_uchar;
pub type uint_fast16_t = ::core::ffi::c_ulong;
pub type uint_fast32_t = ::core::ffi::c_ulong;
pub type uint_fast64_t = ::core::ffi::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NativeSymbol {
    pub symbol: *const ::core::ffi::c_char,
    pub func_ptr: *mut ::core::ffi::c_void,
    pub signature: *const ::core::ffi::c_char,
    pub attachment: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_NativeSymbol() {
    const UNINIT: ::core::mem::MaybeUninit<NativeSymbol> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NativeSymbol>(),
        32usize,
        concat!("Size of: ", stringify!(NativeSymbol))
    );
    assert_eq!(
        ::core::mem::align_of::<NativeSymbol>(),
        8usize,
        concat!("Alignment of ", stringify!(NativeSymbol))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).symbol) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NativeSymbol),
            "::",
            stringify!(symbol)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).func_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NativeSymbol),
            "::",
            stringify!(func_ptr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).signature) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NativeSymbol),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attachment) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NativeSymbol),
            "::",
            stringify!(attachment)
        )
    );
}
impl Default for NativeSymbol {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Get the exported APIs of base lib\n\n @param p_base_lib_apis return the exported API array of base lib\n\n @return the number of the exported API"]
    pub fn get_base_lib_export_apis(p_base_lib_apis: *mut *mut NativeSymbol) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WASMModuleCommon {
    _unused: [u8; 0],
}
pub type wasm_module_t = *mut WASMModuleCommon;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WASMModuleInstanceCommon {
    _unused: [u8; 0],
}
pub type wasm_module_inst_t = *mut WASMModuleInstanceCommon;
pub type WASMFunctionInstanceCommon = ::core::ffi::c_void;
pub type wasm_function_inst_t = *mut WASMFunctionInstanceCommon;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wasm_section_t {
    pub next: *mut wasm_section_t,
    pub section_type: ::core::ffi::c_int,
    pub section_body: *mut u8,
    pub section_body_size: u32,
}
#[test]
fn bindgen_test_layout_wasm_section_t() {
    const UNINIT: ::core::mem::MaybeUninit<wasm_section_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<wasm_section_t>(),
        32usize,
        concat!("Size of: ", stringify!(wasm_section_t))
    );
    assert_eq!(
        ::core::mem::align_of::<wasm_section_t>(),
        8usize,
        concat!("Alignment of ", stringify!(wasm_section_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wasm_section_t),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).section_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wasm_section_t),
            "::",
            stringify!(section_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).section_body) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wasm_section_t),
            "::",
            stringify!(section_body)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).section_body_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wasm_section_t),
            "::",
            stringify!(section_body_size)
        )
    );
}
impl Default for wasm_section_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type aot_section_t = wasm_section_t;
pub type wasm_section_list_t = *mut wasm_section_t;
pub type aot_section_list_t = *mut wasm_section_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WASMExecEnv {
    _unused: [u8; 0],
}
pub type wasm_exec_env_t = *mut WASMExecEnv;
pub const package_type_t_Wasm_Module_Bytecode: package_type_t = 0;
pub const package_type_t_Wasm_Module_AoT: package_type_t = 1;
pub const package_type_t_Package_Type_Unknown: package_type_t = 65535;
pub type package_type_t = ::core::ffi::c_uint;
pub const mem_alloc_type_t_Alloc_With_Pool: mem_alloc_type_t = 0;
pub const mem_alloc_type_t_Alloc_With_Allocator: mem_alloc_type_t = 1;
pub const mem_alloc_type_t_Alloc_With_System_Allocator: mem_alloc_type_t = 2;
pub type mem_alloc_type_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union MemAllocOption {
    pub pool: MemAllocOption__bindgen_ty_1,
    pub allocator: MemAllocOption__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemAllocOption__bindgen_ty_1 {
    pub heap_buf: *mut ::core::ffi::c_void,
    pub heap_size: u32,
}
#[test]
fn bindgen_test_layout_MemAllocOption__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<MemAllocOption__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MemAllocOption__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(MemAllocOption__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<MemAllocOption__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(MemAllocOption__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).heap_buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MemAllocOption__bindgen_ty_1),
            "::",
            stringify!(heap_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).heap_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MemAllocOption__bindgen_ty_1),
            "::",
            stringify!(heap_size)
        )
    );
}
impl Default for MemAllocOption__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemAllocOption__bindgen_ty_2 {
    pub malloc_func: *mut ::core::ffi::c_void,
    pub realloc_func: *mut ::core::ffi::c_void,
    pub free_func: *mut ::core::ffi::c_void,
    pub user_data: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_MemAllocOption__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<MemAllocOption__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MemAllocOption__bindgen_ty_2>(),
        32usize,
        concat!("Size of: ", stringify!(MemAllocOption__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<MemAllocOption__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(MemAllocOption__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).malloc_func) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MemAllocOption__bindgen_ty_2),
            "::",
            stringify!(malloc_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).realloc_func) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MemAllocOption__bindgen_ty_2),
            "::",
            stringify!(realloc_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).free_func) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MemAllocOption__bindgen_ty_2),
            "::",
            stringify!(free_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MemAllocOption__bindgen_ty_2),
            "::",
            stringify!(user_data)
        )
    );
}
impl Default for MemAllocOption__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_MemAllocOption() {
    const UNINIT: ::core::mem::MaybeUninit<MemAllocOption> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MemAllocOption>(),
        32usize,
        concat!("Size of: ", stringify!(MemAllocOption))
    );
    assert_eq!(
        ::core::mem::align_of::<MemAllocOption>(),
        8usize,
        concat!("Alignment of ", stringify!(MemAllocOption))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pool) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MemAllocOption),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MemAllocOption),
            "::",
            stringify!(allocator)
        )
    );
}
impl Default for MemAllocOption {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mem_alloc_info_t {
    pub total_size: u32,
    pub total_free_size: u32,
    pub highmark_size: u32,
}
#[test]
fn bindgen_test_layout_mem_alloc_info_t() {
    const UNINIT: ::core::mem::MaybeUninit<mem_alloc_info_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mem_alloc_info_t>(),
        12usize,
        concat!("Size of: ", stringify!(mem_alloc_info_t))
    );
    assert_eq!(
        ::core::mem::align_of::<mem_alloc_info_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mem_alloc_info_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).total_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_alloc_info_t),
            "::",
            stringify!(total_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).total_free_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_alloc_info_t),
            "::",
            stringify!(total_free_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).highmark_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_alloc_info_t),
            "::",
            stringify!(highmark_size)
        )
    );
}
pub const RunningMode_Mode_Interp: RunningMode = 1;
pub const RunningMode_Mode_Fast_JIT: RunningMode = 2;
pub const RunningMode_Mode_LLVM_JIT: RunningMode = 3;
pub const RunningMode_Mode_Multi_Tier_JIT: RunningMode = 4;
pub type RunningMode = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RuntimeInitArgs {
    pub mem_alloc_type: mem_alloc_type_t,
    pub mem_alloc_option: MemAllocOption,
    pub native_module_name: *const ::core::ffi::c_char,
    pub native_symbols: *mut NativeSymbol,
    pub n_native_symbols: u32,
    pub max_thread_num: u32,
    pub ip_addr: [::core::ffi::c_char; 128usize],
    pub unused: ::core::ffi::c_int,
    pub instance_port: ::core::ffi::c_int,
    pub fast_jit_code_cache_size: u32,
    pub running_mode: RunningMode,
    pub llvm_jit_opt_level: u32,
    pub llvm_jit_size_level: u32,
    pub segue_flags: u32,
    #[doc = " If enabled\n - llvm-jit will output a jitdump file for `perf inject`\n - aot will output a perf-${pid}.map for `perf record`\n - fast-jit. TBD\n - multi-tier-jit. TBD\n - interpreter. TBD"]
    pub enable_linux_perf: bool,
}
#[test]
fn bindgen_test_layout_RuntimeInitArgs() {
    const UNINIT: ::core::mem::MaybeUninit<RuntimeInitArgs> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RuntimeInitArgs>(),
        224usize,
        concat!("Size of: ", stringify!(RuntimeInitArgs))
    );
    assert_eq!(
        ::core::mem::align_of::<RuntimeInitArgs>(),
        8usize,
        concat!("Alignment of ", stringify!(RuntimeInitArgs))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mem_alloc_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeInitArgs),
            "::",
            stringify!(mem_alloc_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mem_alloc_option) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeInitArgs),
            "::",
            stringify!(mem_alloc_option)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).native_module_name) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeInitArgs),
            "::",
            stringify!(native_module_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).native_symbols) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeInitArgs),
            "::",
            stringify!(native_symbols)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_native_symbols) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeInitArgs),
            "::",
            stringify!(n_native_symbols)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_thread_num) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeInitArgs),
            "::",
            stringify!(max_thread_num)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ip_addr) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeInitArgs),
            "::",
            stringify!(ip_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeInitArgs),
            "::",
            stringify!(unused)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).instance_port) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeInitArgs),
            "::",
            stringify!(instance_port)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fast_jit_code_cache_size) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeInitArgs),
            "::",
            stringify!(fast_jit_code_cache_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).running_mode) as usize - ptr as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeInitArgs),
            "::",
            stringify!(running_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).llvm_jit_opt_level) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeInitArgs),
            "::",
            stringify!(llvm_jit_opt_level)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).llvm_jit_size_level) as usize - ptr as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeInitArgs),
            "::",
            stringify!(llvm_jit_size_level)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).segue_flags) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeInitArgs),
            "::",
            stringify!(segue_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).enable_linux_perf) as usize - ptr as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeInitArgs),
            "::",
            stringify!(enable_linux_perf)
        )
    );
}
impl Default for RuntimeInitArgs {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type wasm_valkind_t = u8;
pub const wasm_valkind_enum_WASM_I32: wasm_valkind_enum = 0;
pub const wasm_valkind_enum_WASM_I64: wasm_valkind_enum = 1;
pub const wasm_valkind_enum_WASM_F32: wasm_valkind_enum = 2;
pub const wasm_valkind_enum_WASM_F64: wasm_valkind_enum = 3;
pub const wasm_valkind_enum_WASM_ANYREF: wasm_valkind_enum = 128;
pub const wasm_valkind_enum_WASM_FUNCREF: wasm_valkind_enum = 129;
pub type wasm_valkind_enum = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wasm_ref_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wasm_val_t {
    pub kind: wasm_valkind_t,
    pub __paddings: [u8; 7usize],
    pub of: wasm_val_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wasm_val_t__bindgen_ty_1 {
    pub i32_: i32,
    pub i64_: i64,
    pub f32_: f32,
    pub f64_: f64,
    pub foreign: usize,
    pub ref_: *mut wasm_ref_t,
}
#[test]
fn bindgen_test_layout_wasm_val_t__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<wasm_val_t__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<wasm_val_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(wasm_val_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<wasm_val_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(wasm_val_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).i32_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wasm_val_t__bindgen_ty_1),
            "::",
            stringify!(i32_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).i64_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wasm_val_t__bindgen_ty_1),
            "::",
            stringify!(i64_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).f32_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wasm_val_t__bindgen_ty_1),
            "::",
            stringify!(f32_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).f64_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wasm_val_t__bindgen_ty_1),
            "::",
            stringify!(f64_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).foreign) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wasm_val_t__bindgen_ty_1),
            "::",
            stringify!(foreign)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ref_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wasm_val_t__bindgen_ty_1),
            "::",
            stringify!(ref_)
        )
    );
}
impl Default for wasm_val_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_wasm_val_t() {
    const UNINIT: ::core::mem::MaybeUninit<wasm_val_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<wasm_val_t>(),
        16usize,
        concat!("Size of: ", stringify!(wasm_val_t))
    );
    assert_eq!(
        ::core::mem::align_of::<wasm_val_t>(),
        8usize,
        concat!("Alignment of ", stringify!(wasm_val_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kind) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wasm_val_t),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__paddings) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(wasm_val_t),
            "::",
            stringify!(__paddings)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).of) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wasm_val_t),
            "::",
            stringify!(of)
        )
    );
}
impl Default for wasm_val_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const log_level_t_WASM_LOG_LEVEL_FATAL: log_level_t = 0;
pub const log_level_t_WASM_LOG_LEVEL_ERROR: log_level_t = 1;
pub const log_level_t_WASM_LOG_LEVEL_WARNING: log_level_t = 2;
pub const log_level_t_WASM_LOG_LEVEL_DEBUG: log_level_t = 3;
pub const log_level_t_WASM_LOG_LEVEL_VERBOSE: log_level_t = 4;
pub type log_level_t = ::core::ffi::c_uint;
extern "C" {
    #[doc = " Initialize the WASM runtime environment, and also initialize\n the memory allocator with system allocator, which calls os_malloc\n to allocate memory\n\n @return true if success, false otherwise"]
    pub fn wasm_runtime_init() -> bool;
}
extern "C" {
    #[doc = " Initialize the WASM runtime environment, WASM running mode,\n and also initialize the memory allocator and register native symbols,\n which are specified with init arguments\n\n @param init_args specifies the init arguments\n\n @return return true if success, false otherwise"]
    pub fn wasm_runtime_full_init(init_args: *mut RuntimeInitArgs) -> bool;
}
extern "C" {
    #[doc = " Set the log level. To be called after the runtime is initialized.\n\n @param level the log level to set"]
    pub fn wasm_runtime_set_log_level(level: log_level_t);
}
extern "C" {
    #[doc = " Query whether a certain running mode is supported for the runtime\n\n @param running_mode the running mode to query\n\n @return true if this running mode is supported, false otherwise"]
    pub fn wasm_runtime_is_running_mode_supported(running_mode: RunningMode) -> bool;
}
extern "C" {
    #[doc = " Set the default running mode for the runtime. It is inherited\n to set the running mode of a module instance when it is instantiated,\n and can be changed by calling wasm_runtime_set_running_mode\n\n @param running_mode the running mode to set\n\n @return true if success, false otherwise"]
    pub fn wasm_runtime_set_default_running_mode(running_mode: RunningMode) -> bool;
}
extern "C" {
    #[doc = " Destroy the WASM runtime environment."]
    pub fn wasm_runtime_destroy();
}
extern "C" {
    #[doc = " Allocate memory from runtime memory environment.\n\n @param size bytes need to allocate\n\n @return the pointer to memory allocated"]
    pub fn wasm_runtime_malloc(size: ::core::ffi::c_uint) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " Reallocate memory from runtime memory environment\n\n @param ptr the original memory\n @param size bytes need to reallocate\n\n @return the pointer to memory reallocated"]
    pub fn wasm_runtime_realloc(
        ptr: *mut ::core::ffi::c_void,
        size: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn wasm_runtime_free(ptr: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn wasm_runtime_get_mem_alloc_info(mem_alloc_info: *mut mem_alloc_info_t) -> bool;
}
extern "C" {
    #[doc = " Get the package type of a buffer.\n\n @param buf the package buffer\n @param size the package buffer size\n\n @return the package type, return Package_Type_Unknown if the type is unknown"]
    pub fn get_package_type(buf: *const u8, size: u32) -> package_type_t;
}
extern "C" {
    #[doc = " Check whether a file is an AOT XIP (Execution In Place) file\n\n @param buf the package buffer\n @param size the package buffer size\n\n @return true if success, false otherwise"]
    pub fn wasm_runtime_is_xip_file(buf: *const u8, size: u32) -> bool;
}
#[doc = " Callback to load a module file into a buffer in multi-module feature"]
pub type module_reader = ::core::option::Option<
    unsafe extern "C" fn(
        module_type: package_type_t,
        module_name: *const ::core::ffi::c_char,
        p_buffer: *mut *mut u8,
        p_size: *mut u32,
    ) -> bool,
>;
#[doc = " Callback to release the buffer loaded by module_reader callback"]
pub type module_destroyer =
    ::core::option::Option<unsafe extern "C" fn(buffer: *mut u8, size: u32)>;
extern "C" {
    #[doc = " Setup callbacks for reading and releasing a buffer about a module file\n\n @param reader a callback to read a module file into a buffer\n @param destroyer a callback to release above buffer"]
    pub fn wasm_runtime_set_module_reader(reader: module_reader, destroyer: module_destroyer);
}
extern "C" {
    #[doc = " Give the \"module\" a name \"module_name\".\n Can not assign a new name to a module if it already has a name\n\n @param module_name indicate a name\n @param module the target module\n @param error_buf output of the exception info\n @param error_buf_size the size of the exception string\n\n @return true means success, false means failed"]
    pub fn wasm_runtime_register_module(
        module_name: *const ::core::ffi::c_char,
        module: wasm_module_t,
        error_buf: *mut ::core::ffi::c_char,
        error_buf_size: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Check if there is already a loaded module named module_name in the\n runtime. Repeately loading a module with the same name is not allowed.\n\n @param module_name indicate a name\n\n @return return WASM module loaded, NULL if failed"]
    pub fn wasm_runtime_find_module_registered(
        module_name: *const ::core::ffi::c_char,
    ) -> wasm_module_t;
}
extern "C" {
    #[doc = " Load a WASM module from a specified byte buffer. The byte buffer can be\n WASM binary data when interpreter or JIT is enabled, or AOT binary data\n when AOT is enabled. If it is AOT binary data, it must be 4-byte aligned.\n\n Note: In case of AOT XIP modules, the runtime doesn't make modifications\n to the buffer. (Except the \"Known issues\" mentioned in doc/xip.md.)\n Otherwise, the runtime can make modifications to the buffer for its\n internal purposes. Thus, in general, it isn't safe to create multiple\n modules from a single buffer.\n\n @param buf the byte buffer which contains the WASM/AOT binary data,\n        note that the byte buffer must be writable since runtime may\n        change its content for footprint and performance purpose, and\n        it must be referencable until wasm_runtime_unload is called\n @param size the size of the buffer\n @param error_buf output of the exception info\n @param error_buf_size the size of the exception string\n\n @return return WASM module loaded, NULL if failed"]
    pub fn wasm_runtime_load(
        buf: *mut u8,
        size: u32,
        error_buf: *mut ::core::ffi::c_char,
        error_buf_size: u32,
    ) -> wasm_module_t;
}
extern "C" {
    #[doc = " Load a WASM module from a specified WASM or AOT section list.\n\n @param section_list the section list which contains each section data\n @param is_aot whether the section list is AOT section list\n @param error_buf output of the exception info\n @param error_buf_size the size of the exception string\n\n @return return WASM module loaded, NULL if failed"]
    pub fn wasm_runtime_load_from_sections(
        section_list: wasm_section_list_t,
        is_aot: bool,
        error_buf: *mut ::core::ffi::c_char,
        error_buf_size: u32,
    ) -> wasm_module_t;
}
extern "C" {
    #[doc = " Unload a WASM module.\n\n @param module the module to be unloaded"]
    pub fn wasm_runtime_unload(module: wasm_module_t);
}
extern "C" {
    #[doc = " Get the module hash of a WASM module, currently only available on\n linux-sgx platform when the remote attestation feature is enabled\n\n @param module the WASM module to retrieve\n\n @return the module hash of the WASM module"]
    pub fn wasm_runtime_get_module_hash(module: wasm_module_t) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[doc = " Set WASI parameters.\n\n While this API operates on a module, these parameters will be used\n only when the module is instantiated. That is, you can consider these\n as extra parameters for wasm_runtime_instantiate().\n\n @param module        The module to set WASI parameters.\n @param dir_list      The list of directories to preopen. (real path)\n @param dir_count     The number of elements in dir_list.\n @param map_dir_list  The list of directories to preopen. (mapped path)\n                      Format for each map entry: <guest-path>::<host-path>\n @param map_dir_count The number of elements in map_dir_list.\n                      If map_dir_count is smaller than dir_count,\n                      mapped path is assumed to be same as the\n                      corresponding real path for the rest of entries.\n @param env           The list of environment variables.\n @param env_count     The number of elements in env.\n @param argv          The list of command line arguments.\n @param argc          The number of elements in argv.\n @param stdin_handle  The raw host handle to back WASI STDIN_FILENO.\n                      If an invalid handle is specified (e.g. -1 on POSIX,\n                      INVALID_HANDLE_VALUE on Windows), the platform default\n                      for STDIN is used.\n @param stdoutfd      The raw host handle to back WASI STDOUT_FILENO.\n                      If an invalid handle is specified (e.g. -1 on POSIX,\n                      INVALID_HANDLE_VALUE on Windows), the platform default\n                      for STDOUT is used.\n @param stderrfd      The raw host handle to back WASI STDERR_FILENO.\n                      If an invalid handle is specified (e.g. -1 on POSIX,\n                      INVALID_HANDLE_VALUE on Windows), the platform default\n                      for STDERR is used."]
    pub fn wasm_runtime_set_wasi_args_ex(
        module: wasm_module_t,
        dir_list: *mut *const ::core::ffi::c_char,
        dir_count: u32,
        map_dir_list: *mut *const ::core::ffi::c_char,
        map_dir_count: u32,
        env: *mut *const ::core::ffi::c_char,
        env_count: u32,
        argv: *mut *mut ::core::ffi::c_char,
        argc: ::core::ffi::c_int,
        stdinfd: i64,
        stdoutfd: i64,
        stderrfd: i64,
    );
}
extern "C" {
    #[doc = " Set WASI parameters.\n\n Same as wasm_runtime_set_wasi_args_ex but with default stdio handles"]
    pub fn wasm_runtime_set_wasi_args(
        module: wasm_module_t,
        dir_list: *mut *const ::core::ffi::c_char,
        dir_count: u32,
        map_dir_list: *mut *const ::core::ffi::c_char,
        map_dir_count: u32,
        env: *mut *const ::core::ffi::c_char,
        env_count: u32,
        argv: *mut *mut ::core::ffi::c_char,
        argc: ::core::ffi::c_int,
    );
}
extern "C" {
    pub fn wasm_runtime_set_wasi_addr_pool(
        module: wasm_module_t,
        addr_pool: *mut *const ::core::ffi::c_char,
        addr_pool_size: u32,
    );
}
extern "C" {
    pub fn wasm_runtime_set_wasi_ns_lookup_pool(
        module: wasm_module_t,
        ns_lookup_pool: *mut *const ::core::ffi::c_char,
        ns_lookup_pool_size: u32,
    );
}
extern "C" {
    #[doc = " Instantiate a WASM module.\n\n @param module the WASM module to instantiate\n @param default_stack_size the default stack size of the module instance when the\n        exec env's operation stack isn't created by user, e.g. API\n        wasm_application_execute_main() and wasm_application_execute_func()\n        create the operation stack internally with the stack size specified\n        here. And API wasm_runtime_create_exec_env() creates the operation\n        stack with stack size specified by its parameter, the stack size\n        specified here is ignored.\n @param host_managed_heap_size the default heap size of the module instance, a heap will\n        be created besides the app memory space. Both wasm app and native\n        function can allocate memory from the heap.\n @param error_buf buffer to output the error info if failed\n @param error_buf_size the size of the error buffer\n\n @return return the instantiated WASM module instance, NULL if failed"]
    pub fn wasm_runtime_instantiate(
        module: wasm_module_t,
        default_stack_size: u32,
        host_managed_heap_size: u32,
        error_buf: *mut ::core::ffi::c_char,
        error_buf_size: u32,
    ) -> wasm_module_inst_t;
}
extern "C" {
    #[doc = " Set the running mode of a WASM module instance, override the\n default running mode of the runtime. Note that it only makes sense when\n the input is a wasm bytecode file: for the AOT file, runtime always runs\n it with AOT engine, and this function always returns true.\n\n @param module_inst the WASM module instance to set running mode\n @param running_mode the running mode to set\n\n @return true if success, false otherwise"]
    pub fn wasm_runtime_set_running_mode(
        module_inst: wasm_module_inst_t,
        running_mode: RunningMode,
    ) -> bool;
}
extern "C" {
    #[doc = " Get the running mode of a WASM module instance, if no running mode\n is explicitly set the default running mode of runtime will\n be used and returned. Note that it only makes sense when the input is a\n wasm bytecode file: for the AOT file, this function always returns 0.\n\n @param module_inst the WASM module instance to query for running mode\n\n @return the running mode this module instance currently use"]
    pub fn wasm_runtime_get_running_mode(module_inst: wasm_module_inst_t) -> RunningMode;
}
extern "C" {
    #[doc = " Deinstantiate a WASM module instance, destroy the resources.\n\n @param module_inst the WASM module instance to destroy"]
    pub fn wasm_runtime_deinstantiate(module_inst: wasm_module_inst_t);
}
extern "C" {
    #[doc = " Get WASM module from WASM module instance\n\n @param module_inst the WASM module instance to retrieve\n\n @return the WASM module"]
    pub fn wasm_runtime_get_module(module_inst: wasm_module_inst_t) -> wasm_module_t;
}
extern "C" {
    pub fn wasm_runtime_is_wasi_mode(module_inst: wasm_module_inst_t) -> bool;
}
extern "C" {
    pub fn wasm_runtime_lookup_wasi_start_function(
        module_inst: wasm_module_inst_t,
    ) -> wasm_function_inst_t;
}
extern "C" {
    #[doc = " Get WASI exit code.\n\n After a WASI command completed its execution, an embedder can\n call this function to get its exit code. (that is, the value given\n to proc_exit.)\n\n @param module_inst the module instance"]
    pub fn wasm_runtime_get_wasi_exit_code(module_inst: wasm_module_inst_t) -> u32;
}
extern "C" {
    #[doc = " Lookup an exported function in the WASM module instance.\n\n @param module_inst the module instance\n @param name the name of the function\n @param signature the signature of the function, ignored currently\n\n @return the function instance found, NULL if not found"]
    pub fn wasm_runtime_lookup_function(
        module_inst: wasm_module_inst_t,
        name: *const ::core::ffi::c_char,
        signature: *const ::core::ffi::c_char,
    ) -> wasm_function_inst_t;
}
extern "C" {
    #[doc = " Get parameter count of the function instance\n\n @param func_inst the function instance\n @param module_inst the module instance the function instance belongs to\n\n @return the parameter count of the function instance"]
    pub fn wasm_func_get_param_count(
        func_inst: wasm_function_inst_t,
        module_inst: wasm_module_inst_t,
    ) -> u32;
}
extern "C" {
    #[doc = " Get result count of the function instance\n\n @param func_inst the function instance\n @param module_inst the module instance the function instance belongs to\n\n @return the result count of the function instance"]
    pub fn wasm_func_get_result_count(
        func_inst: wasm_function_inst_t,
        module_inst: wasm_module_inst_t,
    ) -> u32;
}
extern "C" {
    #[doc = " Get parameter types of the function instance\n\n @param func_inst the function instance\n @param module_inst the module instance the function instance belongs to\n @param param_types the parameter types returned"]
    pub fn wasm_func_get_param_types(
        func_inst: wasm_function_inst_t,
        module_inst: wasm_module_inst_t,
        param_types: *mut wasm_valkind_t,
    );
}
extern "C" {
    #[doc = " Get result types of the function instance\n\n @param func_inst the function instance\n @param module_inst the module instance the function instance belongs to\n @param result_types the result types returned"]
    pub fn wasm_func_get_result_types(
        func_inst: wasm_function_inst_t,
        module_inst: wasm_module_inst_t,
        result_types: *mut wasm_valkind_t,
    );
}
extern "C" {
    #[doc = " Create execution environment for a WASM module instance.\n\n @param module_inst the module instance\n @param stack_size the stack size to execute a WASM function\n\n @return the execution environment, NULL if failed, e.g. invalid\n         stack size is passed"]
    pub fn wasm_runtime_create_exec_env(
        module_inst: wasm_module_inst_t,
        stack_size: u32,
    ) -> wasm_exec_env_t;
}
extern "C" {
    #[doc = " Destroy the execution environment.\n\n @param exec_env the execution environment to destroy"]
    pub fn wasm_runtime_destroy_exec_env(exec_env: wasm_exec_env_t);
}
extern "C" {
    #[doc = " Get the singleton execution environment for the instance.\n\n Note: The singleton execution environment is the execution\n environment used internally by the runtime for the API functions\n like wasm_application_execute_main, which don't take explicit\n execution environment. It's associated to the corresponding\n module instance and managed by the runtime. The API user should\n not destroy it with wasm_runtime_destroy_exec_env.\n\n @param module_inst the module instance\n\n @return exec_env the execution environment to destroy"]
    pub fn wasm_runtime_get_exec_env_singleton(module_inst: wasm_module_inst_t) -> wasm_exec_env_t;
}
extern "C" {
    #[doc = " Start debug instance based on given execution environment.\n Note:\n   The debug instance will be destroyed during destroying the\n   execution environment, developers don't need to destroy it\n   manually.\n   If the cluster of this execution environment has already\n   been bound to a debug instance, this function will return true\n   directly.\n   If developer spawns some exec_env by wasm_runtime_spawn_exec_env,\n   don't need to call this function for every spawned exec_env as\n   they are sharing the same cluster with the main exec_env.\n\n @param exec_env the execution environment to start debug instance\n @param port     the port for the debug server to listen on.\n                 0 means automatic assignment.\n                 -1 means to use the global setting in RuntimeInitArgs.\n\n @return debug port if success, 0 otherwise."]
    pub fn wasm_runtime_start_debug_instance_with_port(exec_env: wasm_exec_env_t, port: i32)
        -> u32;
}
extern "C" {
    #[doc = " Same as wasm_runtime_start_debug_instance_with_port(env, -1)."]
    pub fn wasm_runtime_start_debug_instance(exec_env: wasm_exec_env_t) -> u32;
}
extern "C" {
    #[doc = " Initialize the thread environment.\n Note:\n   If developer creates a child thread by himself to call the\n   the wasm function in that thread, he should call this API\n   firstly before calling the wasm function and then call\n   wasm_runtime_destroy_thread_env() after calling the wasm\n   function. If the thread is created from the runtime API,\n   it is unnecessary to call these two APIs.\n\n @return true if success, false otherwise"]
    pub fn wasm_runtime_init_thread_env() -> bool;
}
extern "C" {
    #[doc = " Destroy the thread environment"]
    pub fn wasm_runtime_destroy_thread_env();
}
extern "C" {
    #[doc = " Whether the thread environment is initialized"]
    pub fn wasm_runtime_thread_env_inited() -> bool;
}
extern "C" {
    #[doc = " Get WASM module instance from execution environment\n\n @param exec_env the execution environment to retrieve\n\n @return the WASM module instance"]
    pub fn wasm_runtime_get_module_inst(exec_env: wasm_exec_env_t) -> wasm_module_inst_t;
}
extern "C" {
    #[doc = " Set WASM module instance of execution environment\n Caution:\n   normally the module instance is bound with the execution\n   environment one by one, if multiple module instances want\n   to share to the same execution environment, developer should\n   be responsible for the backup and restore of module instance\n\n @param exec_env the execution environment\n @param module_inst the WASM module instance to set"]
    pub fn wasm_runtime_set_module_inst(exec_env: wasm_exec_env_t, module_inst: wasm_module_inst_t);
}
extern "C" {
    #[doc = " Call the given WASM function of a WASM module instance with\n arguments (bytecode and AoT).\n\n @param exec_env the execution environment to call the function,\n   which must be created from wasm_create_exec_env()\n @param function the function to call\n @param argc total cell number that the function parameters occupy,\n   a cell is a slot of the uint32 array argv[], e.g. i32/f32 argument\n   occupies one cell, i64/f64 argument occupies two cells, note that\n   it might be different from the parameter number of the function\n @param argv the arguments. If the function has return value,\n   the first (or first two in case 64-bit return value) element of\n   argv stores the return value of the called WASM function after this\n   function returns.\n\n @return true if success, false otherwise and exception will be thrown,\n   the caller can call wasm_runtime_get_exception to get the exception\n   info."]
    pub fn wasm_runtime_call_wasm(
        exec_env: wasm_exec_env_t,
        function: wasm_function_inst_t,
        argc: u32,
        argv: *mut u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Call the given WASM function of a WASM module instance with\n provided results space and arguments (bytecode and AoT).\n\n @param exec_env the execution environment to call the function,\n   which must be created from wasm_create_exec_env()\n @param function the function to call\n @param num_results the number of results\n @param results the pre-alloced pointer to get the results\n @param num_args the number of arguments\n @param args the arguments\n\n @return true if success, false otherwise and exception will be thrown,\n   the caller can call wasm_runtime_get_exception to get the exception\n   info."]
    pub fn wasm_runtime_call_wasm_a(
        exec_env: wasm_exec_env_t,
        function: wasm_function_inst_t,
        num_results: u32,
        results: *mut wasm_val_t,
        num_args: u32,
        args: *mut wasm_val_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Call the given WASM function of a WASM module instance with\n provided results space and variant arguments (bytecode and AoT).\n\n @param exec_env the execution environment to call the function,\n   which must be created from wasm_create_exec_env()\n @param function the function to call\n @param num_results the number of results\n @param results the pre-alloced pointer to get the results\n @param num_args the number of arguments\n @param ... the variant arguments\n\n @return true if success, false otherwise and exception will be thrown,\n   the caller can call wasm_runtime_get_exception to get the exception\n   info."]
    pub fn wasm_runtime_call_wasm_v(
        exec_env: wasm_exec_env_t,
        function: wasm_function_inst_t,
        num_results: u32,
        results: *mut wasm_val_t,
        num_args: u32,
        ...
    ) -> bool;
}
extern "C" {
    #[doc = " Call a function reference of a given WASM runtime instance with\n arguments.\n\n Note: this can be used to call a function which is not exported\n by the module explicitly. You might consider it as an abstraction\n violation.\n\n @param exec_env the execution environment to call the function\n   which must be created from wasm_create_exec_env()\n @param element_index the function reference index, usually\n   prvovided by the caller of a registed native function\n @param argc the number of arguments\n @param argv the arguments.  If the function method has return value,\n   the first (or first two in case 64-bit return value) element of\n   argv stores the return value of the called WASM function after this\n   function returns.\n\n @return true if success, false otherwise and exception will be thrown,\n   the caller can call wasm_runtime_get_exception to get exception info."]
    pub fn wasm_runtime_call_indirect(
        exec_env: wasm_exec_env_t,
        element_index: u32,
        argc: u32,
        argv: *mut u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Find the unique main function from a WASM module instance\n and execute that function.\n\n @param module_inst the WASM module instance\n @param argc the number of arguments\n @param argv the arguments array, if the main function has return value,\n   *(int*)argv stores the return value of the called main function after\n   this function returns.\n\n @return true if the main function is called, false otherwise and exception\n   will be thrown, the caller can call wasm_runtime_get_exception to get\n   the exception info."]
    pub fn wasm_application_execute_main(
        module_inst: wasm_module_inst_t,
        argc: i32,
        argv: *mut *mut ::core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Find the specified function in argv[0] from a WASM module instance\n and execute that function.\n\n @param module_inst the WASM module instance\n @param name the name of the function to execute.\n  to indicate the module name via: $module_name$function_name\n  or just a function name: function_name\n @param argc the number of arguments\n @param argv the arguments array\n\n @return true if the specified function is called, false otherwise and\n   exception will be thrown, the caller can call wasm_runtime_get_exception\n   to get the exception info."]
    pub fn wasm_application_execute_func(
        module_inst: wasm_module_inst_t,
        name: *const ::core::ffi::c_char,
        argc: i32,
        argv: *mut *mut ::core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Get exception info of the WASM module instance.\n\n @param module_inst the WASM module instance\n\n @return the exception string"]
    pub fn wasm_runtime_get_exception(
        module_inst: wasm_module_inst_t,
    ) -> *const ::core::ffi::c_char;
}
extern "C" {
    #[doc = " Set exception info of the WASM module instance.\n\n @param module_inst the WASM module instance\n\n @param exception the exception string"]
    pub fn wasm_runtime_set_exception(
        module_inst: wasm_module_inst_t,
        exception: *const ::core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " Clear exception info of the WASM module instance.\n\n @param module_inst the WASM module instance"]
    pub fn wasm_runtime_clear_exception(module_inst: wasm_module_inst_t);
}
extern "C" {
    #[doc = " Terminate the WASM module instance.\n\n This function causes the module instance fail as if it raised a trap.\n\n This is intended to be used in situations like:\n\n  - A thread is executing the WASM module instance\n    (eg. it's in the middle of `wasm_application_execute_main`)\n\n  - Another thread has a copy of `wasm_module_inst_t` of\n    the module instance and wants to terminate it asynchronously.\n\n @param module_inst the WASM module instance"]
    pub fn wasm_runtime_terminate(module_inst: wasm_module_inst_t);
}
extern "C" {
    #[doc = " Set custom data to WASM module instance.\n Note:\n  If WAMR_BUILD_LIB_PTHREAD is enabled, this API\n  will spread the custom data to all threads\n\n @param module_inst the WASM module instance\n @param custom_data the custom data to be set"]
    pub fn wasm_runtime_set_custom_data(
        module_inst: wasm_module_inst_t,
        custom_data: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Get the custom data within a WASM module instance.\n\n @param module_inst the WASM module instance\n\n @return the custom data (NULL if not set yet)"]
    pub fn wasm_runtime_get_custom_data(
        module_inst: wasm_module_inst_t,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " Set the memory bounds checks flag of a WASM module instance.\n\n @param module_inst the WASM module instance\n @param enable the flag to enable/disable the memory bounds checks"]
    pub fn wasm_runtime_set_bounds_checks(module_inst: wasm_module_inst_t, enable: bool);
}
extern "C" {
    #[doc = " Check if the memory bounds checks flag is enabled for a WASM module instance.\n\n @param module_inst the WASM module instance\n @return true if the memory bounds checks flag is enabled, false otherwise"]
    pub fn wasm_runtime_is_bounds_checks_enabled(module_inst: wasm_module_inst_t) -> bool;
}
extern "C" {
    #[doc = " Allocate memory from the heap of WASM module instance\n\n Note: wasm_runtime_module_malloc can call heap functions inside\n the module instance and thus cause a memory growth.\n This API needs to be used very carefully when you have a native\n pointers to the module instance memory obtained with\n wasm_runtime_addr_app_to_native or similar APIs.\n\n @param module_inst the WASM module instance which contains heap\n @param size the size bytes to allocate\n @param p_native_addr return native address of the allocated memory\n        if it is not NULL, and return NULL if memory malloc failed\n\n @return the allocated memory address, which is a relative offset to the\n         base address of the module instance's memory space. Note that\n         it is not an absolute address.\n         Return non-zero if success, zero if failed."]
    pub fn wasm_runtime_module_malloc(
        module_inst: wasm_module_inst_t,
        size: u32,
        p_native_addr: *mut *mut ::core::ffi::c_void,
    ) -> u32;
}
extern "C" {
    #[doc = " Free memory to the heap of WASM module instance\n\n @param module_inst the WASM module instance which contains heap\n @param ptr the pointer to free"]
    pub fn wasm_runtime_module_free(module_inst: wasm_module_inst_t, ptr: u32);
}
extern "C" {
    #[doc = " Allocate memory from the heap of WASM module instance and initialize\n the memory with src\n\n @param module_inst the WASM module instance which contains heap\n @param src the source data to copy\n @param size the size of the source data\n\n @return the allocated memory address, which is a relative offset to the\n         base address of the module instance's memory space. Note that\n         it is not an absolute address.\n         Return non-zero if success, zero if failed."]
    pub fn wasm_runtime_module_dup_data(
        module_inst: wasm_module_inst_t,
        src: *const ::core::ffi::c_char,
        size: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " Validate the app address, check whether it belongs to WASM module\n instance's address space, or in its heap space or memory space.\n\n @param module_inst the WASM module instance\n @param app_offset the app address to validate, which is a relative address\n @param size the size bytes of the app address\n\n @return true if success, false otherwise. If failed, an exception will\n         be thrown."]
    pub fn wasm_runtime_validate_app_addr(
        module_inst: wasm_module_inst_t,
        app_offset: u32,
        size: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Similar to wasm_runtime_validate_app_addr(), except that the size parameter\n is not provided. This function validates the app string address, check\n whether it belongs to WASM module instance's address space, or in its heap\n space or memory space. Moreover, it checks whether it is the offset of a\n string that is end with '\\0'.\n\n Note: The validation result, especially the NUL termination check,\n is not reliable for a module instance with multiple threads because\n other threads can modify the heap behind us.\n\n @param module_inst the WASM module instance\n @param app_str_offset the app address of the string to validate, which is a\n        relative address\n\n @return true if success, false otherwise. If failed, an exception will\n         be thrown."]
    pub fn wasm_runtime_validate_app_str_addr(
        module_inst: wasm_module_inst_t,
        app_str_offset: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Validate the native address, check whether it belongs to WASM module\n instance's address space, or in its heap space or memory space.\n\n @param module_inst the WASM module instance\n @param native_ptr the native address to validate, which is an absolute\n        address\n @param size the size bytes of the app address\n\n @return true if success, false otherwise. If failed, an exception will\n         be thrown."]
    pub fn wasm_runtime_validate_native_addr(
        module_inst: wasm_module_inst_t,
        native_ptr: *mut ::core::ffi::c_void,
        size: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Convert app address(relative address) to native address(absolute address)\n\n Note that native addresses to module instance memory can be invalidated\n on a memory growth. (Except shared memory, whose native addresses are\n stable.)\n\n @param module_inst the WASM module instance\n @param app_offset the app adress\n\n @return the native address converted"]
    pub fn wasm_runtime_addr_app_to_native(
        module_inst: wasm_module_inst_t,
        app_offset: u32,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " Convert native address(absolute address) to app address(relative address)\n\n @param module_inst the WASM module instance\n @param native_ptr the native address\n\n @return the app address converted"]
    pub fn wasm_runtime_addr_native_to_app(
        module_inst: wasm_module_inst_t,
        native_ptr: *mut ::core::ffi::c_void,
    ) -> u32;
}
extern "C" {
    #[doc = " Get the app address range (relative address) that a app address belongs to\n\n @param module_inst the WASM module instance\n @param app_offset the app address to retrieve\n @param p_app_start_offset buffer to output the app start offset if not NULL\n @param p_app_end_offset buffer to output the app end offset if not NULL\n\n @return true if success, false otherwise."]
    pub fn wasm_runtime_get_app_addr_range(
        module_inst: wasm_module_inst_t,
        app_offset: u32,
        p_app_start_offset: *mut u32,
        p_app_end_offset: *mut u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Get the native address range (absolute address) that a native address\n belongs to\n\n @param module_inst the WASM module instance\n @param native_ptr the native address to retrieve\n @param p_native_start_addr buffer to output the native start address\n        if not NULL\n @param p_native_end_addr buffer to output the native end address\n        if not NULL\n\n @return true if success, false otherwise."]
    pub fn wasm_runtime_get_native_addr_range(
        module_inst: wasm_module_inst_t,
        native_ptr: *mut u8,
        p_native_start_addr: *mut *mut u8,
        p_native_end_addr: *mut *mut u8,
    ) -> bool;
}
extern "C" {
    #[doc = " Register native functions with same module name\n\n Note: The array `native_symbols` should not be read-only because the\n library can modify it in-place.\n\n Note: After successful call of this function, the array `native_symbols`\n is owned by the library.\n\n @param module_name the module name of the native functions\n @param native_symbols specifies an array of NativeSymbol structures which\n        contain the names, function pointers and signatures\n        Note: WASM runtime will not allocate memory to clone the data, so\n              user must ensure the array can be used forever\n        Meanings of letters in function signature:\n          'i': the parameter is i32 type\n          'I': the parameter is i64 type\n          'f': the parameter is f32 type\n          'F': the parameter is f64 type\n          'r': the parameter is externref type, it should be a uintptr_t in host\n          '*': the parameter is a pointer (i32 in WASM), and runtime will\n               auto check its boundary before calling the native function.\n               If it is followed by '~', the checked length of the pointer\n               is gotten from the following parameter, if not, the checked\n               length of the pointer is 1.\n          '~': the parameter is the pointer's length with i32 type, and must\n               follow after '*'\n          '$': the parameter is a string (i32 in WASM), and runtime will\n               auto check its boundary before calling the native function\n @param n_native_symbols specifies the number of native symbols in the array\n\n @return true if success, false otherwise"]
    pub fn wasm_runtime_register_natives(
        module_name: *const ::core::ffi::c_char,
        native_symbols: *mut NativeSymbol,
        n_native_symbols: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Register native functions with same module name, similar to\n   wasm_runtime_register_natives, the difference is that runtime passes raw\n arguments to native API, which means that the native API should be defined as\n   void foo(wasm_exec_env_t exec_env, uint64 *args);\n and native API should extract arguments one by one from args array with macro\n   native_raw_get_arg\n and write the return value back to args[0] with macro\n   native_raw_return_type and native_raw_set_return"]
    pub fn wasm_runtime_register_natives_raw(
        module_name: *const ::core::ffi::c_char,
        native_symbols: *mut NativeSymbol,
        n_native_symbols: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Undo wasm_runtime_register_natives or wasm_runtime_register_natives_raw\n\n @param module_name    Should be the same as the corresponding\n                       wasm_runtime_register_natives.\n                       (Same in term of strcmp.)\n\n @param native_symbols Should be the same as the corresponding\n                       wasm_runtime_register_natives.\n                       (Same in term of pointer comparison.)\n\n @return true if success, false otherwise"]
    pub fn wasm_runtime_unregister_natives(
        module_name: *const ::core::ffi::c_char,
        native_symbols: *mut NativeSymbol,
    ) -> bool;
}
extern "C" {
    #[doc = " Get attachment of native function from execution environment\n\n @param exec_env the execution environment to retrieve\n\n @return the attachment of native function"]
    pub fn wasm_runtime_get_function_attachment(
        exec_env: wasm_exec_env_t,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " Set user data to execution environment.\n\n @param exec_env the execution environment\n @param user_data the user data to be set"]
    pub fn wasm_runtime_set_user_data(
        exec_env: wasm_exec_env_t,
        user_data: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Get the user data within execution environment.\n\n @param exec_env the execution environment\n\n @return the user data (NULL if not set yet)"]
    pub fn wasm_runtime_get_user_data(exec_env: wasm_exec_env_t) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " Dump runtime memory consumption, including:\n     Exec env memory consumption\n     WASM module memory consumption\n     WASM module instance memory consumption\n     stack and app heap used info\n\n @param exec_env the execution environment"]
    pub fn wasm_runtime_dump_mem_consumption(exec_env: wasm_exec_env_t);
}
extern "C" {
    #[doc = " Dump runtime performance profiler data of each function\n\n @param module_inst the WASM module instance to profile"]
    pub fn wasm_runtime_dump_perf_profiling(module_inst: wasm_module_inst_t);
}
extern "C" {
    #[doc = " Return total wasm functions' execution time in ms\n\n @param module_inst the WASM module instance to profile"]
    pub fn wasm_runtime_sum_wasm_exec_time(module_inst: wasm_module_inst_t) -> f64;
}
extern "C" {
    #[doc = " Return execution time in ms of a given wasm funciton with\n  func_name. If the function is not found, return 0.\n\n @param module_inst the WASM module instance to profile\n @param func_name could be an export name or a name in the\n                  name section"]
    pub fn wasm_runtime_get_wasm_func_exec_time(
        inst: wasm_module_inst_t,
        func_name: *const ::core::ffi::c_char,
    ) -> f64;
}
pub type wasm_thread_callback_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: wasm_exec_env_t,
        arg2: *mut ::core::ffi::c_void,
    ) -> *mut ::core::ffi::c_void,
>;
pub type wasm_thread_t = usize;
extern "C" {
    #[doc = " Set the max thread num per cluster.\n\n @param num maximum thread num"]
    pub fn wasm_runtime_set_max_thread_num(num: u32);
}
extern "C" {
    #[doc = " Spawn a new exec_env, the spawned exec_env\n   can be used in other threads\n\n @param num the original exec_env\n\n @return the spawned exec_env if success, NULL otherwise"]
    pub fn wasm_runtime_spawn_exec_env(exec_env: wasm_exec_env_t) -> wasm_exec_env_t;
}
extern "C" {
    #[doc = " Destroy the spawned exec_env\n\n @param exec_env the spawned exec_env"]
    pub fn wasm_runtime_destroy_spawned_exec_env(exec_env: wasm_exec_env_t);
}
extern "C" {
    #[doc = " Spawn a thread from the given exec_env\n\n @param exec_env the original exec_env\n @param tid thread id to be returned to the caller\n @param callback the callback function provided by the user\n @param arg the arguments passed to the callback\n\n @return 0 if success, -1 otherwise"]
    pub fn wasm_runtime_spawn_thread(
        exec_env: wasm_exec_env_t,
        tid: *mut wasm_thread_t,
        callback: wasm_thread_callback_t,
        arg: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    #[doc = " Wait a spawned thread to terminate\n\n @param tid thread id\n @param retval if not NULL, output the return value of the thread\n\n @return 0 if success, error number otherwise"]
    pub fn wasm_runtime_join_thread(
        tid: wasm_thread_t,
        retval: *mut *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    #[doc = " Map external object to an internal externref index: if the index\n   has been created, return it, otherwise create the index.\n\n @param module_inst the WASM module instance that the extern object\n        belongs to\n @param extern_obj the external object to be mapped\n @param p_externref_idx return externref index of the external object\n\n @return true if success, false otherwise"]
    pub fn wasm_externref_obj2ref(
        module_inst: wasm_module_inst_t,
        extern_obj: *mut ::core::ffi::c_void,
        p_externref_idx: *mut u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Delete external object registered by `wasm_externref_obj2ref`.\n\n @param module_inst the WASM module instance that the extern object\n        belongs to\n @param extern_obj the external object to be deleted\n\n @return true if success, false otherwise"]
    pub fn wasm_externref_objdel(
        module_inst: wasm_module_inst_t,
        extern_obj: *mut ::core::ffi::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " Set cleanup callback to release external object.\n\n @param module_inst the WASM module instance that the extern object\n        belongs to\n @param extern_obj the external object to which to set the\n        `extern_obj_cleanup` cleanup callback.\n @param extern_obj_cleanup a callback to release `extern_obj`\n\n @return true if success, false otherwise"]
    pub fn wasm_externref_set_cleanup(
        module_inst: wasm_module_inst_t,
        extern_obj: *mut ::core::ffi::c_void,
        extern_obj_cleanup: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void),
        >,
    ) -> bool;
}
extern "C" {
    #[doc = " Retrieve the external object from an internal externref index\n\n @param externref_idx the externref index to retrieve\n @param p_extern_obj return the mapped external object of\n        the externref index\n\n @return true if success, false otherwise"]
    pub fn wasm_externref_ref2obj(
        externref_idx: u32,
        p_extern_obj: *mut *mut ::core::ffi::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " Retain an extern object which is mapped to the internal externref\n   so that the object won't be cleaned during extern object reclaim\n   if it isn't used.\n\n @param externref_idx the externref index of an external object\n        to retain\n @return true if success, false otherwise"]
    pub fn wasm_externref_retain(externref_idx: u32) -> bool;
}
extern "C" {
    #[doc = " Dump the call stack to stdout\n\n @param exec_env the execution environment"]
    pub fn wasm_runtime_dump_call_stack(exec_env: wasm_exec_env_t);
}
extern "C" {
    #[doc = " Get the size required to store the call stack contents, including\n the space for terminating null byte ('\\0')\n\n @param exec_env the execution environment\n\n @return size required to store the contents, 0 means error"]
    pub fn wasm_runtime_get_call_stack_buf_size(exec_env: wasm_exec_env_t) -> u32;
}
extern "C" {
    #[doc = " Dump the call stack to buffer.\n\n @note this function is not thread-safe, please only use this API\n       when the exec_env is not executing\n\n @param exec_env the execution environment\n @param buf buffer to store the dumped content\n @param len length of the buffer\n\n @return bytes dumped to the buffer, including the terminating null\n         byte ('\\0'), 0 means error and data in buf may be invalid"]
    pub fn wasm_runtime_dump_call_stack_to_buf(
        exec_env: wasm_exec_env_t,
        buf: *mut ::core::ffi::c_char,
        len: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " Get the size required to store the LLVM PGO profile data\n\n @param module_inst the WASM module instance\n\n @return size required to store the contents, 0 means error"]
    pub fn wasm_runtime_get_pgo_prof_data_size(module_inst: wasm_module_inst_t) -> u32;
}
extern "C" {
    #[doc = " Dump the LLVM PGO profile data to buffer\n\n @param module_inst the WASM module instance\n @param buf buffer to store the dumped content\n @param len length of the buffer\n\n @return bytes dumped to the buffer, 0 means error and data in buf\n         may be invalid"]
    pub fn wasm_runtime_dump_pgo_prof_data_to_buf(
        module_inst: wasm_module_inst_t,
        buf: *mut ::core::ffi::c_char,
        len: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " Get a custom section by name\n\n @param module_comm the module to find\n @param name name of the custom section\n @param len return the length of the content if found\n\n @return Custom section content (not including the name length\n         and name string) if found, NULL otherwise"]
    pub fn wasm_runtime_get_custom_section(
        module_comm: wasm_module_t,
        name: *const ::core::ffi::c_char,
        len: *mut u32,
    ) -> *const u8;
}
extern "C" {
    #[doc = " Get WAMR semantic version"]
    pub fn wasm_runtime_get_version(major: *mut u32, minor: *mut u32, patch: *mut u32);
}
extern "C" {
    #[doc = " Check whether an import func `(import <module_name> <func_name> (func ...))`\n is linked or not with runtime registered natvie functions"]
    pub fn wasm_runtime_is_import_func_linked(
        module_name: *const ::core::ffi::c_char,
        func_name: *const ::core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Check whether an import global `(import <module_name> <global_name> (global ...))`\n is linked or not with runtime registered natvie globals"]
    pub fn wasm_runtime_is_import_global_linked(
        module_name: *const ::core::ffi::c_char,
        global_name: *const ::core::ffi::c_char,
    ) -> bool;
}
pub const enlarge_memory_error_reason_t_INTERNAL_ERROR: enlarge_memory_error_reason_t = 0;
pub const enlarge_memory_error_reason_t_MAX_SIZE_REACHED: enlarge_memory_error_reason_t = 1;
pub type enlarge_memory_error_reason_t = ::core::ffi::c_uint;
pub type enlarge_memory_error_callback_t = ::core::option::Option<
    unsafe extern "C" fn(
        inc_page_count: u32,
        current_memory_size: u64,
        memory_index: u32,
        failure_reason: enlarge_memory_error_reason_t,
        instance: wasm_module_inst_t,
        exec_env: wasm_exec_env_t,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
extern "C" {
    #[doc = " Setup callback invoked when memory.grow fails"]
    pub fn wasm_runtime_set_enlarge_mem_error_callback(
        callback: enlarge_memory_error_callback_t,
        user_data: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    pub fn wasm_runtime_create_context_key(
        dtor: ::core::option::Option<
            unsafe extern "C" fn(inst: wasm_module_inst_t, ctx: *mut ::core::ffi::c_void),
        >,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn wasm_runtime_destroy_context_key(key: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn wasm_runtime_set_context(
        inst: wasm_module_inst_t,
        key: *mut ::core::ffi::c_void,
        ctx: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    pub fn wasm_runtime_set_context_spread(
        inst: wasm_module_inst_t,
        key: *mut ::core::ffi::c_void,
        ctx: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    pub fn wasm_runtime_get_context(
        inst: wasm_module_inst_t,
        key: *mut ::core::ffi::c_void,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn wasm_runtime_begin_blocking_op(exec_env: wasm_exec_env_t) -> bool;
}
extern "C" {
    pub fn wasm_runtime_end_blocking_op(exec_env: wasm_exec_env_t);
}
